// evmone: Fast Ethereum Virtual Machine implementation
// Copyright 2023 The evmone Authors.
// SPDX-License-Identifier: Apache-2.0

#include "blockchaintest.hpp"
#include <CLI/CLI.hpp>
#include <evmone/evmone.h>
#include <evmone/version.h>
#include <gtest/gtest.h>
#include <iostream>

namespace fs = std::filesystem;

namespace
{
/// Implementation of a gtest Test which runs all blockchain tests from a given file.
class BlockchainGTestFile : public testing::Test
{
    fs::path m_json_test_file;
    evmc::VM& m_vm;

public:
    explicit BlockchainGTestFile(fs::path json_test_file, evmc::VM& vm) noexcept
      : m_json_test_file{std::move(json_test_file)}, m_vm{vm}
    {}

    void TestBody() final
    {
        std::ifstream f{m_json_test_file};

        try
        {
            evmone::test::run_blockchain_tests(evmone::test::load_blockchain_tests(f), m_vm);
        }
        catch (const evmone::test::UnsupportedTestFeature& ex)
        {
            GTEST_SKIP() << ex.what();
        }
    }

    static void register_one(const std::string& suite_name, const fs::path& file, evmc::VM& vm)
    {
        testing::RegisterTest(suite_name.c_str(), file.stem().string().c_str(), nullptr, nullptr,
            file.string().c_str(), 0,
            [file, &vm]() -> testing::Test* { return new BlockchainGTestFile(file, vm); });
    }
};

/// Implementation of a gtest Test which runs a single blockchain test.
class BlockchainGTest : public testing::Test
{
    const evmone::test::BlockchainTest m_blockchain_test;
    evmc::VM& m_vm;

public:
    explicit BlockchainGTest(evmone::test::BlockchainTest blockchain_test, evmc::VM& vm) noexcept
      : m_blockchain_test{std::move(blockchain_test)}, m_vm{vm}
    {}

    void TestBody() final
    {
        evmone::test::run_blockchain_tests(std::array{m_blockchain_test}, m_vm);
    }

    static void register_one(const evmone::test::BlockchainTest& test,
        const std::string& suite_name, const std::string& test_name, const fs::path& file,
        evmc::VM& vm)
    {
        testing::RegisterTest(suite_name.c_str(), test_name.c_str(), nullptr, nullptr,
            file.string().c_str(), 0,
            [test, &vm]() -> testing::Test* { return new BlockchainGTest(test, vm); });
    }
};

void register_test_files(const fs::path& root, evmc::VM& vm)
{
    if (is_directory(root))
    {
        std::vector<fs::path> test_files;
        std::copy_if(fs::recursive_directory_iterator{root}, fs::recursive_directory_iterator{},
            std::back_inserter(test_files), [](const fs::directory_entry& entry) {
                // "index.json" files are just lists of tests generated by other tools.
                return entry.is_regular_file() && entry.path().extension() == ".json" &&
                       entry.path().filename() != "index.json";
            });
        std::ranges::sort(test_files);

        for (const auto& p : test_files)
            BlockchainGTestFile::register_one(fs::relative(p, root).parent_path().string(), p, vm);
    }
    else  // Treat as a file.
    {
        std::ifstream f{root};
        try
        {
            const auto tests = evmone::test::load_blockchain_tests(f);
            for (const auto& test : tests)
                BlockchainGTest::register_one(test, root.string(), test.name, root, vm);
        }
        catch (const evmone::test::UnsupportedTestFeature& ex)
        {
            std::cerr << ex.what() << ": " << root.string() << '\n';
        }
    }
}
}  // namespace


int main(int argc, char* argv[])
{
    try
    {
        testing::InitGoogleTest(&argc, argv);  // Process GoogleTest flags.

        CLI::App app{"evmone blockchain test runner"};

        app.set_version_flag("--version", "evmone-blockchaintest " EVMONE_VERSION);

        std::vector<std::string> paths;
        app.add_option("path", paths,
               "Path to test file or directory. For a directory, all .json "
               "files (except index.json) are considered test files, and each file is treated as a "
               "separate test. For a file, all tests in the file are treated as separate tests.")
            ->required()
            ->check(CLI::ExistingPath);

        bool trace_flag = false;
        app.add_flag("--trace", trace_flag, "Enable EVM tracing");

        CLI11_PARSE(app, argc, argv);

        evmc::VM vm{evmc_create_evmone()};

        if (trace_flag)
            vm.set_option("trace", "1");

        for (const auto& p : paths)
            register_test_files(p, vm);

        return RUN_ALL_TESTS();
    }
    catch (const std::exception& ex)
    {
        std::cerr << ex.what() << "\n";
        return -1;
    }
}
